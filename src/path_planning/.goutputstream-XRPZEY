#include "path_planning/path_planning.h"


Planner::Planner()
{	
	_service2 = _node.advertiseService("start", &Planner::start, this);
	_service1 = _node.advertiseService("goal", &Planner::goal, this);
	_sub = _node.subscribe("/map", 1000, &Planner::readMap, this);
	_path_pub = _node.advertise<nav_msgs::Path>("/move_base_simple/path", 10);
	_marker_pub = _node.advertise<visualization_msgs::Marker>("visualization_marker", 1);
	_vel_pub = _node.advertise<geometry_msgs::Twist>("/robot0/cmd_vel", 1);
	
	//transform a point once every second
	_timer = _node.createTimer(ros::Duration(1.0), &Planner::currentPosition, this);
	
}

bool Planner::start(path_planning::startRequest &req, 
					path_planning::startResponse &res)
{
	ROS_INFO_STREAM("start");
	res.success = true;
	return true;
}

void Planner::readMap(const nav_msgs::OccupancyGridConstPtr& msg)
{
	_height = msg->info.height;
	_width = msg->info.width;
	_resolution = msg->info.resolution;
	_map_size = _height * _width;
	
	_index = new int[_map_size];
	
	for (unsigned int ii = 0; ii <= _map_size; ii++) 
	{
		_index[ii] = msg->data[ii];
	}
	
	ROS_INFO_STREAM("height, width, resolution: " 
					<< _height << " " << _width << " " << _resolution);
}

void Planner::currentPosition(const ros::TimerEvent& e)
{
	try
	{
		tf::StampedTransform transform;
		
		
		_listener.lookupTransform("/map", "robot0", ros::Time(0), transform);
		
		_curr_cell_x = transform.getOrigin()[0]; //transform.getOrigin().x()
		_curr_cell_y = transform.getOrigin()[1];
		_curr_cell_z = transform.getOrigin()[2];
		
		ROS_INFO_STREAM("CURRENT POSITION: " << _curr_cell_x << " " 
							<< _curr_cell_y << " " << _curr_cell_z);
		
		_yaw = tf::getYaw(transform.getRotation());
		ROS_INFO_STREAM("rotation: " << _yaw);
							
	}
	catch(tf::TransformException& ex){
		ROS_ERROR("%s",ex.what());
        ros::Duration(2.0).sleep();
	}
	
}

bool Planner::goal(path_planning::goalRequest &req, 
					path_planning::goalResponse &res)
{
	ROS_INFO_STREAM("goal");

	//~ if (random())
	//~ {
		//~ res.success = true;
	//~ }
	//~ 
	//~ else
	//~ {
		//~ ROS_INFO_STREAM("WRONG GOAL");
		//~ res.success = false;
		//~ return 1;
	//~ }
	//~ 
	std::vector <cell> best_path;
	best_path.clear();
	
	_goal_cell_x = req.goal_cell_x;
	_goal_cell_y = req.goal_cell_y;
	
	_goal_map_x = worldToMap(_goal_cell_x); // map(pixel)
	_goal_map_y = worldToMap(_goal_cell_y);
	
	if (rightCell(_goal_map_x, _goal_map_y))
	{
		best_path = path(_curr_cell_x, _curr_cell_y, _goal_map_x, _goal_map_y);
		ROS_INFO_STREAM("Got a start: " << _curr_cell_x << " " << _curr_cell_y 
							<< " and a goal: " << _goal_cell_x << " " << _goal_cell_y);
			
		nav_msgs::Path plan;
		geometry_msgs::PoseStamped pose;

//~ 
		plan.header.frame_id = "/map";
			
			
		for (unsigned int ii = 0; ii < best_path.size(); ii ++)
		{

			// geometry_msgs/PoseStamped[] -> geometry_msgs/Pose -> geometry_msgs/Point
			pose.pose.position.x = best_path[ii].x * _resolution;
			pose.pose.position.y = best_path[ii].y * _resolution;
			pose.pose.position.z = 0.0;

			//~ // geometry_msgs/PoseStamped[] -> geometry_msgs/Pose -> geometry_msgs/Quaternion
			pose.pose.orientation.x = 0.0;
			pose.pose.orientation.y = 0.0;
			pose.pose.orientation.z = 0.0;
			pose.pose.orientation.w = 1.0;

			plan.poses.push_back(pose);
				
		}
		_path_pub.publish(plan);
		res.success = true;
	}
	else
	{
		ROS_INFO_STREAM("WRONG GOAL");
		res.success = false;
		return 1;
	}
	
	return true;
}

bool Planner::random()
{
	std::vector <cell> best_path;
	best_path.clear();
	
	int w = _width * _resolution;
	int h = _height * _resolution;
	
	_goal_cell_x = rand() % w;
	_goal_cell_y = rand() % h;
	
	//~ ROS_INFO_STREAM("Goal cell " << _goal_cell_x << " " << _goal_cell_y);
	_goal_map_x = worldToMap(_goal_cell_x); // map(pixel)
	_goal_map_y = worldToMap(_goal_cell_y);
	
	while (!rightCell(_goal_map_x, _goal_map_y))
	{
		_goal_cell_x = rand() % w;
		_goal_cell_y = rand() % h;
	
		//~ ROS_INFO_STREAM("Goal cell " << _goal_cell_x << " " << _goal_cell_y);
		_goal_map_x = worldToMap(_goal_cell_x); // map(pixel)
		_goal_map_y = worldToMap(_goal_cell_y);
		
	}
	
	best_path = path(_curr_cell_x, _curr_cell_y, _goal_map_x, _goal_map_y);
	ROS_INFO_STREAM("Got a start: " << _curr_cell_x << " " << _curr_cell_y 
						<< " and a goal: " << _goal_cell_x << " " << _goal_cell_y);
		
	nav_msgs::Path plan;
	geometry_msgs::PoseStamped pose;


	plan.header.frame_id = "/map";
		
		
	for (unsigned int ii = 0; ii < best_path.size(); ii ++)
	{

		// geometry_msgs/PoseStamped[] -> geometry_msgs/Pose -> geometry_msgs/Point
		pose.pose.position.x = best_path[ii].x * _resolution;
		pose.pose.position.y = best_path[ii].y * _resolution;
		pose.pose.position.z = 0.0;

		// geometry_msgs/PoseStamped[] -> geometry_msgs/Pose -> geometry_msgs/Quaternion
		pose.pose.orientation.x = 0.0;
		pose.pose.orientation.y = 0.0;
		pose.pose.orientation.z = 0.0;
		pose.pose.orientation.w = 1.0;

		plan.poses.push_back(pose);
			
	}
	_path_pub.publish(plan);
	return true;
}

//elegxei an oi suntetagmenes tou keliou pou dothike anhkei ston xarth kai an einai eleuthero h oxi
bool Planner::rightCell(int x, int y)
{
	bool valid = true;
	
	if (x >= _width || y >= _height || x < 0 || y < 0) 
	{
		valid = false;
	}
	else
	{
		int b = y * _width + x;
		//~ ROS_INFO_STREAM("index " << _index[b]);
		
		if (_index[b] == 0 )
		{
			//~ ROS_INFO_STREAM(" FREE ");			
		}
		else if (_index[b] == 100)
		{
			//~ ROS_INFO_STREAM(" OBSTACLE ");
			valid = false;
		}
		else
		{
			//~ ROS_INFO_STREAM(" UNKNOWN ");
			valid = false;
		}
	}
	return valid;
}

//metatrepei tis suntetagmenes x,y tou xarth se suntetagmenes keliou
int Planner::worldToMap(int w_coor)
{
	int m_coor = w_coor / _resolution;
	return m_coor;
}

//metatrepei tis suntetagmenes x,y tou keliou se suntetagmenes tou xarth
void Planner::mapToWorld(int m_x, int m_y)
{
	int w_x = m_x * _resolution;
	int w_y = m_y * _resolution;
}

//calculate h(x), manhattan distance
int Planner::calculateHScore (int curr_map_x, int curr_map_y, 
								int goal_map_x, int goal_map_y) 
{
	int h_score = abs(curr_map_x - goal_map_x) + abs(curr_map_y - goal_map_y);
	return h_score;
}

std::vector <cell> Planner::path (int _curr_cell_x, int _curr_cell_y, 
									int goal_map_x, int goal_map_y)
{
	std::vector <cell> open_list;
	std::vector <cell> closed_list;
	std::vector <cell> best_path;
	std::vector <cell> _came_from;
	
	open_list.clear();
	closed_list.clear();
	best_path.clear();
	_came_from.clear();
	
	cell C;
	cell N_C;
	cell C_F;
	
	int brushfire_flag = 0;
	
	int curr_map_x = worldToMap(_curr_cell_x);
	int curr_map_y = worldToMap(_curr_cell_y);
	float infinity = std::numeric_limits<float>::infinity();
		
	g_score = new float *[_width];
	for (unsigned int ii = 0; ii < _width; ii ++) 
	{
		g_score[ii] = new float [_height];
		for (unsigned int jj = 0; jj < _height; jj ++) 
		{
			g_score[ii][jj] = _map_size + 1;
		}
	}
		
	f_score = new float *[_width];
	for (unsigned int ii = 0; ii < _width; ii ++) 
	{
		f_score[ii] = new float [_height];
		for (unsigned int jj = 0; jj < _height; jj ++) 
		{
			f_score[ii][jj] = std::numeric_limits<float>::infinity();
		}
	}
	
	
	
	int count = 0;
	_brushfire = new float *[_width];
	for (unsigned int ii = 0; ii < _width; ii ++) 
	{
		_brushfire[ii] = new float [_height];
		for (unsigned int jj = 0; jj < _height; jj ++) 
		{
			if (!rightCell(ii, jj))  // ean einai empodio kanei to brushfire iso me mhden
			{
				_brushfire[ii][jj] = 0;
				count ++ ;
			}
			else
			{
				_brushfire[ii][jj] = std::numeric_limits<float>::infinity();
			}
		}
	}
	
	
	float mean_counter = 0;
	//~ ROS_INFO_STREAM("COUNT " << count);
	while (count < _map_size)
	{
		brushfire_flag ++ ;
		for (unsigned int ii = 0; ii < _width; ii ++) 
		{
			for (unsigned int jj = 0; jj < _height; jj ++) 
			{
				if (_brushfire[ii][jj] > brushfire_flag)
				{
					if ((_brushfire[ii][jj - 1] == brushfire_flag - 1) || (_brushfire[ii - 1][jj - 1] == brushfire_flag - 1)
						|| (_brushfire[ii + 1][jj - 1] == brushfire_flag - 1) || (_brushfire[ii][jj + 1] == brushfire_flag - 1)
						|| (_brushfire[ii - 1][jj + 1] == brushfire_flag - 1) || (_brushfire[ii + 1][jj + 1] == brushfire_flag - 1)
						|| (_brushfire[ii - 1][jj] == brushfire_flag - 1) || (_brushfire[ii + 1][jj] == brushfire_flag - 1))
					{
						_brushfire[ii][jj] = brushfire_flag;
						count ++ ;
						mean_counter = mean_counter + _brushfire[ii][jj];
						//~ ROS_INFO_STREAM("COUNT 111  " << count);
					}
				}
			}
		}
		//~ ROS_INFO_STREAM("BRUSHFIRE " << brushfire_flag << " count " << count);
	}
	
	

	//~ for (unsigned int ii = 0; ii < _width; ii ++) 
	//~ {
		//~ for (unsigned int jj = 0; jj < _height; jj ++) 
		//~ {
			//~ while (brushfire_flag)
			//~ {
				//~ for (unsigned int zz = 0; zz < 2 + b; zz ++)
				//~ {
					//~ for (unsigned int kk = 0; kk < 2 + b; kk ++)
					//~ {
						//~ if ((ii + zz - a > 0) && (jj + kk - a > 0))
						//~ {
							//~ if (!rightCell(ii + zz - a, jj + kk - a))
							//~ {
								//~ brushfire_flag = false;
							//~ }
						//~ }
					//~ }
				//~ }
				//~ if (brushfire_flag)
				//~ {
					//~ _brushfire[ii][jj] ++ ;
					//~ a ++ ;
					//~ b = b + 2;
				//~ }
				//~ else
				//~ {
					//~ a = 1;
					//~ b = 1;
				//~ }
				//~ ROS_INFO_STREAM("ii: " << ii);
			//~ }
			//~ brushfire_flag = true;
			//~ ROS_INFO_STREAM("ii: " << ii << " jj: " << jj << " zz: " << _brushfire[ii][jj]);
		//~ }	
	//~ }
	
	
	float std_counter = 0;
	float mean = mean_counter / _map_size;
	float std;
	
	for (unsigned int ii = 0; ii < _width; ii ++)
	{
		for (unsigned int jj = 0; jj < _height; jj ++)
		{
			std_counter = (_brushfire[ii][jj] - mean) * (_brushfire[ii][jj] - mean);
		}
	}
	
	std_counter = std_counter / _map_size;
	std = sqrt(std_counter);
	
	float d = 0.8 * (mean - std);
	
	//~ ROS_INFO_STREAM("MEAN " << mean << " STD " << std << " AAA " << d);
	
	
	
	
	//prosthetw thn trexousa thesh sthn open list
	C.x = curr_map_x;
	C.y = curr_map_y;
	open_list.push_back(C);
	
	int c_f_counter = 0; // gia na kserei apo poio keli egine h eksaplwsh
	int g_counter = 0; // counter gia ta g_score
	int counter = 0; // gia na kserei poio keli tha diagrapsei apo thn open list
		
	g_score[curr_map_x][curr_map_y] = 0; //gia to keli sto opoio vriskomaste
	int h_score = calculateHScore(curr_map_x, curr_map_y, goal_map_x, goal_map_y);
	f_score[curr_map_x][curr_map_y] = g_score[curr_map_x][curr_map_y] + h_score;
	
	while (!open_list.empty() && !(curr_map_x == goal_map_x && curr_map_y == goal_map_y))
	{
		std::vector <cell> neighbour_cell;
		neighbour_cell.clear();
		
		open_list.erase(open_list.begin() + counter);
		closed_list.push_back(C);
			
		float min = infinity;
		float new_g;
		
		
		for (unsigned int ii = 1; ii <= 3; ii ++) 
		{
			for (unsigned int jj = 1; jj <= 3; jj ++) 
			{				
				int mx = curr_map_x + ii - 2; //to x tou geitona
				int my = curr_map_y + jj - 2; //to y tou geitona
				
				//elegxei tous geitones
				if ((ii - 2) == 0 && (jj - 2) == 0)
				{
					//~ ROS_INFO_STREAM("No Neighbour");
				}				
				else
				{
					//elegxw an einai mesa ston xarti kai eleuthero h oxi
					if (rightCell(mx, my))
					{
						if (_brushfire[mx][my] > 10)
						{
							if (g_score[mx][my] == _map_size + 1) //den exei epektathei akoma
							{
								//gia ta diagwnia kelia kelia
								if (((mx - curr_map_x) == -1 && (my - curr_map_y) == -1)
									|| ((mx - curr_map_x) == -1 && (my - curr_map_y) == 1)
									|| ((mx - curr_map_x) == 1 && (my - curr_map_y) == -1)
									|| ((mx - curr_map_x) == 1 && (my - curr_map_y) == 1))
								{
									g_score[mx][my] = g_score[curr_map_x][curr_map_y] + 1.4;
								}
								else //gia ta panw-katw, deksia-aristera kelia
								{
									g_score[mx][my] = g_score[curr_map_x][curr_map_y] + 1;
								}
								
								//~ ROS_INFO_STREAM("Not visited yet");
								h_score = calculateHScore(mx, my, goal_map_x, goal_map_y);
								f_score[mx][my] = g_score[mx][my] + h_score;
								
								//pernaei sthn open list ta geitonika diathesima kelia
								N_C.x = mx;
								N_C.y = my;
								N_C.f_score = f_score[mx][my];
								N_C.cf_x = curr_map_x; //apo auto egine h epektash
								N_C.cf_y = curr_map_y;
								N_C.counter = c_f_counter;
								open_list.push_back(N_C);
							}
							else //to exei ksanaepiskeuthei
							{
								for (unsigned int zz = 0; zz < open_list.size(); zz ++)
								{
									if (curr_map_x + ii - 2 == open_list[zz].x && curr_map_y + jj - 2 == open_list[zz].y)
									{
										//gia ta diagwnia kelia kelia
										if ((mx - curr_map_x) == -1 && (my - curr_map_y) == -1
											|| (mx - curr_map_x) == -1 && (my - curr_map_y) == 1
											|| (mx - curr_map_x) == 1 && (my - curr_map_y) == -1
											|| (mx - curr_map_x) == 1 && (my - curr_map_y) == 1)
										{
											new_g = g_score[curr_map_x][curr_map_y] + 1.4;
										}
										else //gia ta panw-katw, deksia-aristera kelia
										{
											new_g = g_score[curr_map_x][curr_map_y] + 1;
										}
											
										if (new_g < g_score[mx][my])
										{
											g_score[mx][my] = new_g;
											f_score[mx][my] = g_score[mx][my] + calculateHScore(mx, my, goal_map_x, goal_map_y);
											open_list[zz].f_score = f_score[mx][my];
											open_list[zz].cf_x = curr_map_x;
											open_list[zz].cf_y = curr_map_y;
											open_list[zz].counter = c_f_counter;
										}
									}
								}
								//~ ROS_INFO_STREAM("Has visited");
							}
						}
					}
				}
			}
		}
				
		//upologizei to mikrotero f_score apo ta kelia pou exei episkeuthei
		for (unsigned int zz = 0; zz < open_list.size(); zz ++)
		{
			if (min > open_list[zz].f_score)
			{
				min = open_list[zz].f_score;
				curr_map_x = open_list[zz].x;
				curr_map_y = open_list[zz].y;
				counter = zz;
			}
		}
		
		//~ ROS_INFO_STREAM("Next cell " << curr_map_x << " " << curr_map_y);
		C.x = curr_map_x;
		C.y = curr_map_y;
		C_F.x = open_list[counter].cf_x;
		C_F.y = open_list[counter].cf_y;
		C_F.counter = open_list[counter].counter;
		c_f_counter ++ ;
		_came_from.push_back(C_F);
	}
	
	C.x = goal_map_x;
	C.y = goal_map_y;
	C.counter = _came_from.size();
	closed_list.push_back(C);
	_came_from.push_back(C);
	best_path = reconstructPath(_came_from, goal_map_x, goal_map_y);
	
	for (unsigned int ii = 0; ii < _width; ii ++) 
	{
		delete [] g_score[ii];
		delete [] f_score[ii];
		delete [] _brushfire[ii];
	}
	delete [] g_score;
	delete [] f_score;
	delete [] _brushfire;
	//~ delete [] _index;
		

	return best_path;
}


//~ std::vector <cell> Planner::path (int _curr_cell_x, int _curr_cell_y, 
									//~ int goal_map_x, int goal_map_y)
//~ {
	//~ std::vector <cell> open_list;
	//~ std::vector <cell> closed_list;
	//~ std::vector <cell> best_path;
	//~ std::vector <cell> _came_from;
	//~ 
	//~ open_list.clear();
	//~ closed_list.clear();
	//~ best_path.clear();
	//~ _came_from.clear();
	//~ 
	//~ cell C;
	//~ cell N_C;
	//~ cell C_F;
	//~ 
	//~ int curr_map_x = worldToMap(_curr_cell_x);
	//~ int curr_map_y = worldToMap(_curr_cell_y);
	//~ float infinity = std::numeric_limits<float>::infinity();
		//~ 
	//~ g_score = new float *[_width];
	//~ for (unsigned int ii = 0; ii < _width; ii ++) 
	//~ {
		//~ g_score[ii] = new float [_height];
		//~ for (unsigned int jj = 0; jj < _height; jj ++) 
		//~ {
			//~ g_score[ii][jj] = _map_size + 1;
		//~ }
	//~ }
		//~ 
	//~ f_score = new float *[_width];
	//~ for (unsigned int ii = 0; ii < _width; ii ++) 
	//~ {
		//~ f_score[ii] = new float [_height];
		//~ for (unsigned int jj = 0; jj < _height; jj ++) 
		//~ {
			//~ f_score[ii][jj] = std::numeric_limits<float>::infinity();
		//~ }
	//~ }
	//~ 
	//~ _brushfire = new float *[_width];
	//~ for (unsigned int ii = 0; ii < _width; ii ++) 
	//~ {
		//~ _brushfire[ii] = new float [_height];
		//~ for (unsigned int jj = 0; jj < _height; jj ++) 
		//~ {
			//~ if (!rightCell(ii, jj))  // ean einai empodio kanei to brushfire iso me mhden
			//~ {
				//~ _brushfire[ii][jj] = 0;
			//~ }
			//~ else
			//~ {
				//~ _brushfire[ii][jj] = 1;
			//~ }
		//~ }
	//~ }
		//~ 
	//~ //prosthetw thn trexousa thesh sthn open list
	//~ C.x = curr_map_x;
	//~ C.y = curr_map_y;
	//~ open_list.push_back(C);
	//~ 
	//~ int c_f_counter = 0; // gia na kserei apo poio keli egine h eksaplwsh
	//~ int g_counter = 0; // counter gia ta g_score
	//~ int counter = 0; // gia na kserei poio keli tha diagrapsei apo thn open list
		//~ 
	//~ g_score[curr_map_x][curr_map_y] = 0; //gia to keli sto opoio vriskomaste
	//~ int h_score = calculateHScore(curr_map_x, curr_map_y, goal_map_x, goal_map_y);
	//~ f_score[curr_map_x][curr_map_y] = g_score[curr_map_x][curr_map_y] + h_score;
	//~ 
	//~ while (!open_list.empty() && !(curr_map_x == goal_map_x && curr_map_y == goal_map_y))
	//~ {
		//~ std::vector <cell> neighbour_cell;
		//~ neighbour_cell.clear();
		//~ 
		//~ open_list.erase(open_list.begin() + counter);
		//~ closed_list.push_back(C);
			//~ 
		//~ float min = infinity;
		//~ float new_g;
			//~ 
		//~ for (unsigned int ii = 1; ii <= 3; ii ++) 
		//~ {
			//~ for (unsigned int jj = 1; jj <= 3; jj ++) 
			//~ {				
				//~ int mx = curr_map_x + ii - 2; //to x tou geitona
				//~ int my = curr_map_y + jj - 2; //to y tou geitona
				//~ 
				//~ //elegxei tous geitones
				//~ if ((ii - 2) == 0 && (jj - 2) == 0)
				//~ {
					//~ ROS_INFO_STREAM("No Neighbours");
				//~ }				
				//~ else
				//~ {
					//~ //elegxw an einai mesa ston xarti kai eleuthero h oxi
					//~ if (rightCell(mx, my))
					//~ {
						//~ if (g_score[mx][my] == _map_size + 1) //den exei epektathei akoma
						//~ {
							//~ //gia ta diagwnia kelia kelia
							//~ if (((mx - curr_map_x) == -1 && (my - curr_map_y) == -1)
								//~ || ((mx - curr_map_x) == -1 && (my - curr_map_y) == 1)
								//~ || ((mx - curr_map_x) == 1 && (my - curr_map_y) == -1)
								//~ || ((mx - curr_map_x) == 1 && (my - curr_map_y) == 1))
							//~ {
								//~ g_score[mx][my] = g_score[curr_map_x][curr_map_y] + 1.4;
							//~ }
							//~ else //gia ta panw-katw, deksia-aristera kelia
							//~ {
								//~ g_score[mx][my] = g_score[curr_map_x][curr_map_y] + 1;
							//~ }
							//~ 
							//~ ROS_INFO_STREAM("Not visited yet");
							//~ h_score = calculateHScore(mx, my, goal_map_x, goal_map_y);
							//~ f_score[mx][my] = g_score[mx][my] + h_score;
							//~ 
							//~ //pernaei sthn open list ta geitonika diathesima kelia
							//~ N_C.x = mx;
							//~ N_C.y = my;
							//~ N_C.f_score = f_score[mx][my];
							//~ N_C.cf_x = curr_map_x; //apo auto egine h epektash
							//~ N_C.cf_y = curr_map_y;
							//~ N_C.counter = c_f_counter;
							//~ open_list.push_back(N_C);
						//~ }
						//~ else //to exei ksanaepiskeuthei
						//~ {
							//~ for (unsigned int zz = 0; zz < open_list.size(); zz ++)
							//~ {
								//~ if (curr_map_x + ii - 2 == open_list[zz].x && curr_map_y + jj - 2 == open_list[zz].y)
								//~ {
									//~ //gia ta diagwnia kelia kelia
									//~ if ((mx - curr_map_x) == -1 && (my - curr_map_y) == -1
										//~ || (mx - curr_map_x) == -1 && (my - curr_map_y) == 1
										//~ || (mx - curr_map_x) == 1 && (my - curr_map_y) == -1
										//~ || (mx - curr_map_x) == 1 && (my - curr_map_y) == 1)
									//~ {
										//~ new_g = g_score[curr_map_x][curr_map_y] + 1.4;
									//~ }
									//~ else //gia ta panw-katw, deksia-aristera kelia
									//~ {
										//~ new_g = g_score[curr_map_x][curr_map_y] + 1;
									//~ }
										//~ 
									//~ if (new_g < g_score[mx][my])
									//~ {
										//~ g_score[mx][my] = new_g;
										//~ f_score[mx][my] = g_score[mx][my] + calculateHScore(mx, my, goal_map_x, goal_map_y);
										//~ open_list[zz].f_score = f_score[mx][my];
										//~ open_list[zz].cf_x = curr_map_x;
										//~ open_list[zz].cf_y = curr_map_y;
										//~ open_list[zz].counter = c_f_counter;
									//~ }
								//~ }
							//~ }
							//~ ROS_INFO_STREAM("Has visited");
						//~ }
					//~ }
				//~ }
			//~ }
		//~ }
				//~ 
		//~ //upologizei to mikrotero f_score apo ta kelia pou exei episkeuthei
		//~ for (unsigned int zz = 0; zz < open_list.size(); zz ++)
		//~ {
			//~ if (min > open_list[zz].f_score)
			//~ {
				//~ min = open_list[zz].f_score;
				//~ curr_map_x = open_list[zz].x;
				//~ curr_map_y = open_list[zz].y;
				//~ counter = zz;
			//~ }
		//~ }
		//~ 
		//~ ROS_INFO_STREAM("Next cell " << curr_map_x << " " << curr_map_y);
		//~ C.x = curr_map_x;
		//~ C.y = curr_map_y;
		//~ C_F.x = open_list[counter].cf_x;
		//~ C_F.y = open_list[counter].cf_y;
		//~ C_F.counter = open_list[counter].counter;
		//~ c_f_counter ++ ;
		//~ _came_from.push_back(C_F);
	//~ }
	//~ 
	//~ C.x = goal_map_x;
	//~ C.y = goal_map_y;
	//~ C.counter = _came_from.size();
	//~ closed_list.push_back(C);
	//~ _came_from.push_back(C);
	//~ best_path = reconstructPath(_came_from, goal_map_x, goal_map_y);
	//~ 
	//~ for (unsigned int ii = 0; ii < _width; ii ++) 
	//~ {
		//~ delete [] g_score[ii];
		//~ delete [] f_score[ii];
	//~ }
	//~ delete [] g_score;
	//~ delete [] f_score;
	//~ delete [] _index;
		//~ 
//~ 
	//~ return best_path;
//~ }

std::vector <cell> Planner::reconstructPath (const std::vector <cell>& _came_from, 
												int goal_map_x, int goal_map_y)
{
	std::vector <cell> best_path;
	std::vector <cell> subobjective_path;
	
	best_path.clear();
	
	int count = _came_from.size();
	cell B;
	cell S;

	int sub_target_x = goal_map_x;
	int current_x = goal_map_x;
	int current_y = goal_map_y;
	int sub_target_y = goal_map_y;
		
	int counter1 = 0; // for sub_target
	_dokimi = 0;
	
	while (!(count == 0))
	{
		current_x = _came_from[count - 1].x;
		current_y = _came_from[count - 1].y;
		count = _came_from[count - 1].counter;
		
		//~ ROS_INFO_STREAM("reConstructorPath " << current_x << " " << current_y);
		B.x = current_x;
		B.y = current_y;
		best_path.push_back(B);
		
		if (counter1 % 20 == 0)
		{
			S.x = current_x;
			S.y = current_y;
			subobjective_path.push_back(S);
		}
		counter1 ++;
	}
	
	S.x = current_x;
	S.y = current_y;
	subobjective_path.push_back(S);
	_counter = subobjective_path.size();
	
	_target_x = new float [_counter];
	_target_y = new float [_counter];
	for (unsigned int ii = 0; ii < _counter; ii ++) 
	{
		_target_x[ii] = subobjective_path[_counter - 1 - ii].x;
		_target_y[ii] = subobjective_path[_counter - 1 - ii].y;
		
		int i = _target_x[ii];
		int j = _target_y[ii];
		
		ROS_INFO_STREAM("targets " << i << " " << j << " brushfire " << _brushfire[i][j]);
		
	}
	
	//~ for (unsigned int ii = 0; ii < subobjective_path.size(); ii ++)
	//~ {
		//~ sub_target_x = subobjective_path[subobjective_path.size() - 1 - ii].x;
		//~ sub_target_y = subobjective_path[subobjective_path.size() - 1 - ii].y;
//~ 
		//~ current_pose_x = _sub_target.x;
		//~ current_pose_y = _sub_target.y;
	//~ }
	
	_vel_timer = _node.createTimer(ros::Duration(1.0), &Planner::velocity, this);		
	
	visual(subobjective_path);
	return best_path;
}

void Planner::visual(const std::vector <cell>& subobjective_path)
{
	 // Visualize the nodes
    visualization_msgs::Marker marker;
	geometry_msgs::Point p;
	
	marker.header.frame_id = "map";
	marker.header.stamp = ros::Time::now();
	
	marker.type = visualization_msgs::Marker::SPHERE_LIST;
	marker.action = visualization_msgs::Marker::ADD;
	
	marker.id = 0;
	marker.ns = "path_planning";
	
	for (unsigned int ii = 0; ii < subobjective_path.size(); ii ++)
	{
		p.x = subobjective_path[ii].x * _resolution;
		p.y = subobjective_path[ii].y * _resolution;
		p.z = 0;
		marker.points.push_back(p);	
	}
	
	marker.pose.orientation.x = 0.0;
	marker.pose.orientation.y = 0.0;
	marker.pose.orientation.z = 0.0;
	marker.pose.orientation.w = 1.0;
  
	marker.scale.x = 0.15;
	marker.scale.y = 0.15;
	marker.scale.z = 0.00;
	marker.color.a = 1.0;
	marker.color.r = 0.0;
	marker.color.g = 1.0;
	marker.color.b = 0.0;
	
	marker.lifetime = ros::Duration();
	
	_marker_pub.publish(marker);
    
}

void Planner::velocity(const ros::TimerEvent& event)
{
	
	//~ ros::Duration dt = ros::Time::now() - event.last_real;
	
	geometry_msgs::Twist twist;
	
	twist.linear.x = 0.0;
	twist.linear.y = 0.0;
    twist.linear.z = 0.0;
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
    twist.angular.z = 0.0;
	
	if (_dokimi > 0)
	{
		//~ ROS_INFO_STREAM("MPHKE");
		float current_x = _current_pose.x * _resolution;
		float current_y = _current_pose.y * _resolution;
		float sub_target_x = _sub_target.x * _resolution;
		float sub_target_y = _sub_target.y * _resolution;
		
		float dis = distance(current_x, current_y, sub_target_x, sub_target_y);
		float pi = 3.14159;
		ROS_INFO_STREAM(" ");
		//~ ROS_INFO_STREAM("CURRENT " << current_x << " " << current_y);
		//~ ROS_INFO_STREAM("TARGET "  << sub_target_x << " " << sub_target_y);
		
		
		_z = atan2(sub_target_y - current_y, sub_target_x - current_x)/1.0;

		ROS_INFO_STREAM("Z0: " << _z);
		//~ ROS_INFO_STREAM(" ");

		if (!((_yaw < _z + 0.01) && (_yaw > _z - 0.01)))
		{
			twist.angular.z = - _yaw + atan2(sub_target_y - current_y, sub_target_x - current_x)/1.0;
			//~ ROS_INFO_STREAM("YAW: " << _yaw);
			//~ ROS_INFO_STREAM("Z1: " << twist.angular.z);
			if (twist.angular.z > - pi && twist.angular.z < 0)
			{
				twist.angular.z = twist.angular.z / 2.0;
				
				//~ ROS_INFO_STREAM("1 " << twist.angular.z);
			}
			else if (twist.angular.z < - pi)
			{
				twist.angular.z = (twist.angular.z + 2 * pi) / 2.0;
				
				//~ ROS_INFO_STREAM("2 " << twist.angular.z);
			}
			else if (twist.angular.z > pi)
			{
				twist.angular.z = (twist.angular.z - 2 * pi) / 2.0;
				
				//~ ROS_INFO_STREAM("3 " << twist.angular.z);
			}
			else if (twist.angular.z < pi && twist.angular.z > 0)
			{
				twist.angular.z = twist.angular.z / 2.0;
				
				//~ ROS_INFO_STREAM("4 " << twist.angular.z);
			}
			else
			{
				//~ ROS_INFO_STREAM("5 ");
			}
			_vel_pub.publish(twist);
			test();
		}
		else
		{
			twist.linear.x = dis;
			//~ ROS_INFO_STREAM("6 ");
			ROS_INFO_STREAM("X: " << twist.linear.x);
			_vel_pub.publish(twist);
			_dokimi ++;
			//~ ROS_INFO_STREAM("DOKIMI " << _dokimi);
			test();
		}
	}
	else
	{
		_dokimi ++;
		test();
	}
		
}

void Planner::test()
{
	_current_pose.x = _target_x[_dokimi];
	_current_pose.y = _target_y[_dokimi];
	
	_sub_target.x = _target_x[_dokimi + 1];
	_sub_target.y = _target_y[_dokimi + 1];
	
	if (_dokimi > 0)
	{
		_x = _target_x[_dokimi - 1];
		_y = _target_y[_dokimi - 1];
	}
	
	if ((_current_pose.x == _sub_target.x) && (_current_pose.y == _sub_target.y))
	{
		_dokimi = 0;
	}
	
	//~ ROS_INFO_STREAM("D " << _dokimi);
	//~ ROS_INFO_STREAM("CURRENT " << _current_pose.x << " " << _current_pose.y);
	//~ ROS_INFO_STREAM("TARGET " << _sub_target.x << " " << _sub_target.y);
	
}

float Planner::distance(float x1, float y1, float x2, float y2)
{
	float dis = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
	dis = sqrt(dis);
	return dis;
}

void Planner::stop_move()
{
	geometry_msgs::Twist twist;
	
    twist.linear.x = 0.0;
    twist.linear.y = 0.0;
    twist.linear.z = 0.0;
    twist.angular.x = 0.0;
    twist.angular.y = 0.0;
   	twist.angular.z = 0.0;
   	ROS_INFO_STREAM("TELOS");
    
    _vel_pub.publish(twist);
}



